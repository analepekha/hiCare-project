{"version":3,"sources":["js/animation-hero.js"],"names":["TextScramble","constructor","el","chars","update","bind","setText","newText","oldText","innerText","length","Math","max","promise","Promise","resolve","queue","i","from","to","start","floor","random","end","push","cancelAnimationFrame","frameRequest","frame","output","complete","n","char","randomChar","innerHTML","requestAnimationFrame","phrases","document","querySelector","fx","counter","next","then","setTimeout"],"mappings":";AAAA,MAAMA,EACJC,YAAYC,GACV,KAAKA,GAAKA,EACV,KAAKC,MAAQ,MACb,KAAKC,OAAS,KAAKA,OAAOC,KAAK,MAEjCC,QAAQC,GACN,MAAMC,EAAU,KAAKN,GAAGO,UAClBC,EAASC,KAAKC,IAAIJ,EAAQE,OAAQH,EAAQG,QAC1CG,EAAU,IAAIC,QAAQC,GAAY,KAAKA,QAAUA,GACvD,KAAKC,MAAQ,GACb,IAAK,IAAIC,EAAI,EAAGA,EAAIP,EAAQO,IAAK,CAC/B,MAAMC,EAAOV,EAAQS,IAAM,GACrBE,EAAKZ,EAAQU,IAAM,GACnBG,EAAQT,KAAKU,MAAsB,GAAhBV,KAAKW,UACxBC,EAAMH,EAAQT,KAAKU,MAAsB,GAAhBV,KAAKW,UACpC,KAAKN,MAAMQ,KAAK,CAAEN,KAAAA,EAAMC,GAAAA,EAAIC,MAAAA,EAAOG,IAAAA,IAKrC,OAHAE,qBAAqB,KAAKC,cAC1B,KAAKC,MAAQ,EACb,KAAKvB,SACES,EAETT,SACE,IAAIwB,EAAS,GACTC,EAAW,EACf,IAAK,IAAIZ,EAAI,EAAGa,EAAI,KAAKd,MAAMN,OAAQO,EAAIa,EAAGb,IAAK,CACjD,IAAI,KAAEC,EAAI,GAAEC,EAAE,MAAEC,EAAK,IAAEG,EAAG,KAAEQ,GAAS,KAAKf,MAAMC,GAC5C,KAAKU,OAASJ,GAChBM,IACAD,GAAUT,GACD,KAAKQ,OAASP,KAClBW,GAAQpB,KAAKW,SAAW,OAC3BS,EAAO,KAAKC,aACZ,KAAKhB,MAAMC,GAAGc,KAAOA,GAEvBH,GAAU,0BAA4BG,EAAO,WAE7CH,GAAUV,EAGd,KAAKhB,GAAG+B,UAAYL,EAChBC,IAAa,KAAKb,MAAMN,OAC1B,KAAKK,WAEL,KAAKW,aAAeQ,sBAAsB,KAAK9B,QAC/C,KAAKuB,SAGTK,aACE,OAAO,KAAK7B,MAAMQ,KAAKU,MAAMV,KAAKW,SAAW,KAAKnB,MAAMO,UAM5D,MAAMyB,EAAU,CAAC,KAAM,UAAW,UAAW,UACvCjC,EAAKkC,SAASC,cAAc,kBAC5BC,EAAK,IAAItC,EAAaE,GAC5B,IAAIqC,EAAU,EACd,MAAMC,EAAOA,KACXF,EAAGhC,QAAQ6B,EAAQI,IAAUE,KAAK,KAChCC,WAAWF,EAAM,OAEnBD,GAAWA,EAAU,GAAKJ,EAAQzB,QAEpC8B","file":"animation-hero.2cd9b94c.js","sourceRoot":"../src","sourcesContent":["class TextScramble {\n  constructor(el) {\n    this.el = el;\n    this.chars = '___';\n    this.update = this.update.bind(this);\n  }\n  setText(newText) {\n    const oldText = this.el.innerText;\n    const length = Math.max(oldText.length, newText.length);\n    const promise = new Promise(resolve => (this.resolve = resolve));\n    this.queue = [];\n    for (let i = 0; i < length; i++) {\n      const from = oldText[i] || '';\n      const to = newText[i] || '';\n      const start = Math.floor(Math.random() * 40);\n      const end = start + Math.floor(Math.random() * 40);\n      this.queue.push({ from, to, start, end });\n    }\n    cancelAnimationFrame(this.frameRequest);\n    this.frame = 0;\n    this.update();\n    return promise;\n  }\n  update() {\n    let output = '';\n    let complete = 0;\n    for (let i = 0, n = this.queue.length; i < n; i++) {\n      let { from, to, start, end, char } = this.queue[i];\n      if (this.frame >= end) {\n        complete++;\n        output += to;\n      } else if (this.frame >= start) {\n        if (!char || Math.random() < 0.28) {\n          char = this.randomChar();\n          this.queue[i].char = char;\n        }\n        output += '<span class=\"dud-text\">' + char + '</span>';\n      } else {\n        output += from;\n      }\n    }\n    this.el.innerHTML = output;\n    if (complete === this.queue.length) {\n      this.resolve();\n    } else {\n      this.frameRequest = requestAnimationFrame(this.update);\n      this.frame++;\n    }\n  }\n  randomChar() {\n    return this.chars[Math.floor(Math.random() * this.chars.length)];\n  }\n}\n// ——————————————————————————————————————————————————\n// Фразы\n// ——————————————————————————————————————————————————\nconst phrases = ['Hi', 'Natural', 'Healthy', 'Beauty'];\nconst el = document.querySelector('.scramble-text');\nconst fx = new TextScramble(el);\nlet counter = 0;\nconst next = () => {\n  fx.setText(phrases[counter]).then(() => {\n    setTimeout(next, 1000);\n  });\n  counter = (counter + 1) % phrases.length;\n};\nnext();\n"]}